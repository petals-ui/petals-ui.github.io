<!DOCTYPE html> <html lang="zh-CN" dir="ltr"> <head> <meta charset="UTF-8"> <!-- SEO --> <title>控件设计指南 - Petals</title> <!-- 页面渲染兼容性 --> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="renderer" content="webkit"> <meta name="viewport" content="width=device-width,initial-scale=1.0"> <!-- 站点 icon --> <link rel="icon" href="/assets/favicon-3e749ca030e3b71eb2662d947c789061d2da9e0f4ee5f3360cfa9ccbe053c8ba.ico"> <!-- 静态资源 --> <link type="text/css" rel="stylesheet" href="/assets/global-ac269897e47236ac0b00b2e6d175647c6729931857067007dc35711a5f8f3bf9.css"> <link type="text/css" rel="stylesheet" href="/assets/share-2811f36e337fef8021089414f657904b7e88db17d8ecade0688c8c3f5e632a5c.css"> <link type="text/css" rel="stylesheet" href="/assets/pages/post-e81e7d6592f92970c97642e26e18867c0bc2e4291bc2dd0c8e438e8c51d3f3b8.css"><link type="text/css" rel="stylesheet" href="/assets/pages/doc-16c9b148020b39fe4ce60aa4f5fd6861922c962e21e447439776b8a01e182088.css"> <script type="text/javascript" src="/assets/global-b3a80dd53acf48ad7228d6fd741dba15d3845cbc3783bdbbf7244151a45628aa.js"></script> </head> <body class="Page" itemscope itemtype="http://schema.org/WebPage"> <header class="Page-header"> <div class="navbar navbar-static-top"> <div class="container-fluid"> <div class="navbar-header"> <button class="navbar-toggle collapsed" type="button" data-target=".Page-navs" data-toggle="collapse"> <span class="sr-only">切换导航</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <div class="navbar-brand"><a href="https://ntks.ourai.ws/" title="访问「反混沌」" target="_blank" rel="external nofollow">Anti-chaos</a><a href="/" title="回到首页">Petals</a></div> </div> <!-- 导航 --> <nav class="Page-navs navbar-collapse collapse"> <ul class="nav navbar-nav navbar-right"> <li><a href="/guides/">指南</a></li> <li><a href="/controls/">控件</a></li> <li class="dropdown"> <a class="dropdown-toggle" href="/ecosystem/" data-toggle="dropdown">生态 <span class="caret"></span></a> <ul class="dropdown-menu"> <li class="dropdown-header">开发套件</li> <li><a href="https://ntks.ourai.ws/projects/toolbox/" target="_blank" rel="external nofollow">Toolbox</a></li> <li><a href="/" title="跨 JS-based 技术栈控件（UI 组件）体系">Petals</a></li> <li><a href="https://handiejs.github.io/kit/" target="_blank" rel="external nofollow">Handie</a></li> <li class="divider"></li> <li class="dropdown-header">团队协作</li> <li><a href="https://ntks.ourai.ws/guides/coding-style/" target="_blank" rel="external nofollow">代码风格</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" href="/about/" data-toggle="dropdown">关于 <span class="caret"></span></a> <ul class="dropdown-menu"> <li><a href="https://ntks.ourai.ws/team/" target="_blank" rel="external nofollow">团队</a></li> <li><a href="https://github.com/petals-ui" target="_blank" rel="external nofollow">GitHub</a></li> </ul> </li> </ul> </nav> </div> </div> </header> <div class="Page-content"> <aside class="Page-aside"> <div class="AsideBrand"><a href="https://ntks.ourai.ws/" title="访问「反混沌」" target="_blank" rel="external nofollow">Anti-chaos</a><a href="/" title="回到首页">Petals</a></div> <nav class="AsideNav"> <ul> <li> <a href="/guides/">指南总览</a> </li> <li> <span>开发辅助</span> <ul> <li> <a href="/utils/sass/">Sass helper</a> </li> <li> <a href="/utils/css/">CSS 工具类</a> </li> </ul> </li> <li> <span>致开发者</span> <ul> <li> <a class="is-selected" href="/guides/control-design/">控件设计指南</a> </li> <li> <a href="/guides/control-doc/">控件文档指南</a> </li> </ul> </li> </ul> </nav> </aside> <main class="Page-main"> <article class="Article container-fluid"> <header class="Article-header"> <h1 class="Article-title">控件设计指南</h1> </header> <div class="Article-content col-md-9"><p>当设计一个控件时，应该考虑的事情。</p> <h2 id="section">目录结构</h2> <p>每个控件都应当被视作是独立的软件包、模块，所以它的各方面应该是完备的——除了实现控件的代码，还应有详尽的使用说明文档、可交互的在线 demo、完善的测试代码以及用来做一些自动化处理的元数据等。</p> <p>上述材料相关文件的目录结构大体如下：</p> <figure class="highlight"><pre><code class="language-text" data-lang="text"><span></span>component
   ├── demo                       # 示例相关文件
   │   └── ...
   ├── test                       # 测试相关文件
   │   └── ...
   ├── style                      # 样式相关文件
   │   ├── _functions.scss        # Sass 函数（可选）
   │   ├── _properties.scss       # CSS 自定义属性（必需），风格组件的一部分，供外部运行时自定义主题风格
   │   ├── _variables.scss        # Sass 变量（必需），风格组件的一部分，供外部编辑时/编译时自定义主题风格
   │   ├── _mixins.scss           # Sass 混入（可选）
   │   └── _rules.scss            # CSS 规则（必需），视觉组件，具有约束结构的作用
   ├── typing                     # 类型相关文件
   │   ├── custom-properties.ts   # CSS 自定义属性配置项（必需），用于运行时生成 CSS 自定义属性
   │   ├── aliases.ts             # 类型别名（可选）
   │   ├── interfaces.ts          # 结构组件接口（必需）
   │   └── index.ts               # 类型统一导出
   ├── HeadlessComponent.ts       # 无头组件，控件与结构无关的逻辑
   ├── Component.vue              # 结构组件，受生成 HTML 的 JS 库/框架的源码、平台限定的视图结构描述语言影响
   ├── index.ts                   # 模块统一导出
   ├── changelog.md               # 控件变更记录
   ├── readme.md                  # 控件说明文档
   ├── metadata.yml
   └── package.json</code></pre></figure> <h2 id="section-1">命名约定</h2> <h3 id="html--css-class">HTML &amp; CSS class</h3> <p>在<a href="https://en.wikipedia.org/wiki/Component-based_software_engineering">基于组件开发</a>（Component-based Development）的体系中，HTML &amp; CSS class 应当是足够语义化的，让人在视图结构中一眼看到后就知道它是个什么东西，而不是长什么样。</p> <p>因此，HTML &amp; CSS class 的使用理应是 component-first 而非 utility-first——应用 CSS 组件（视觉组件），那些 utility class 作为辅助存在，也就是说，当 CSS 组件自带样式与实际需求有些许不符时，利用 utility class 进行「微调」，而不是在外部重写样式。</p> <p>综上所述，HTML &amp; CSS class 的命名遵循 <a href="http://getbem.com/">BEM</a> 的变体「<a href="https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md">SUIT CSS 命名约定</a>」：</p> <figure class="highlight"><pre><code class="language-css" data-lang="css"><span></span><span class="c">/* 控件 */</span>
<span class="p">.</span><span class="nc">ComponentName</span> <span class="p">{}</span>

<span class="c">/* 控件修饰符 */</span>
<span class="p">.</span><span class="nc">ComponentName--modifierName</span> <span class="p">{}</span>

<span class="c">/* 控件后代 */</span>
<span class="p">.</span><span class="nc">ComponentName-descendentName</span> <span class="p">{}</span>

<span class="c">/* 控件状态 */</span>
<span class="p">.</span><span class="nc">ComponentName</span><span class="p">.</span><span class="nc">is-stateOfComponent</span> <span class="p">{}</span>

<span class="c">/* 辅助工具 */</span>
<span class="p">.</span><span class="nc">u-utilityName</span> <span class="p">{}</span></code></pre></figure> <p>控件基类 <code>.ComponentName</code> 及其后代 <code>.ComponentName-descendentName</code> 很好理解，它们之间天然具有层级关系，共同描述了一个控件的结构：</p> <figure class="highlight"><pre><code class="language-html" data-lang="html"><span></span><span class="c">&lt;!-- 用语义化 HTML 标签 --&gt;</span>
<span class="p">&lt;</span><span class="nt">article</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Article&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">header</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Article-header&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h1</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Article-title&quot;</span><span class="p">&gt;</span>文章标题<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">header</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">section</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Article-section&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>章节标题<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>章节段落<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">footer</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Article-footer&quot;</span><span class="p">&gt;</span>一些其他信息<span class="p">&lt;/</span><span class="nt">footer</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 用非语义化 HTML 标签，更能凸显出 class 命名语义化的作用 --&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Article&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Article-header&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h1</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Article-title&quot;</span><span class="p">&gt;</span>文章标题<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Article-section&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>章节标题<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>章节段落<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Article-footer&quot;</span><span class="p">&gt;</span>一些其他信息<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span></code></pre></figure> <p>而控件修饰符 <code>.ComponentName--modifierName</code> 和控件状态 <code>.ComponentName.is-stateOfComponent</code> 有时就不能很好地区分何时该用哪个了。就拿按钮控件来说，它的颜色、是否可用与尺寸，哪个该用修饰符？哪个算是状态？</p> <p>一个比较简单的判断标准：如果是控件的特性，即不会因为什么条件而改变的，用修饰符；倘若会因某个条件满足与否而变化，那就是状态。</p> <figure class="highlight"><pre><code class="language-html" data-lang="html"><span></span><span class="c">&lt;!-- 用语义化 HTML 标签，大号（尺寸）的主要（功能色）操作按钮 --&gt;</span>
<span class="p">&lt;</span><span class="nt">button</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Button Button--primary Button--large&quot;</span><span class="p">&gt;</span>新增<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 用非语义化 HTML 标签，不可用（状态）的危险（功能色）操作按钮 --&gt;</span>
<span class="p">&lt;</span><span class="nt">span</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;Button Button--danger is-disabled&quot;</span><span class="p">&gt;</span>批量删除<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span></code></pre></figure> <p>应该注意的是，控件修饰符和控件状态都是直接加在控件的根节点上的，也就是要跟在控件基类的后面，不能用于控件后代上。假如一个控件后代需要程序化地改变它本身的样式，要用辅助工具类而不是状态类。当一个控件后代的结构、功能等变得复杂时，要将其封装成一个新的控件。</p> <h3 id="sass--css-">Sass 变量与 CSS 自定义属性</h3> <p>在这里，Sass 变量与 CSS 自定义属性的命名方式比较类似，它们大概都是 <code>&lt;namespace&gt;-&lt;component-name&gt;[-descendent-name|-modifier-name][-state]-(variable-name|property-name)</code> 的形式。其中，<code>&lt;namespace&gt;</code> 部分是 <code>petals</code>。</p> <p>Sass 变量是以 <code>$__petals</code> 或 <code>$petals</code> 开头，与控件名之间用 <code>--</code> 连接，前者是内部使用（私有）的，上层开发者无需关心，后者是供外部在编辑时/编译时定制用；CSS 自定义属性则用 <code>--petals</code> 开头，以 <code>-</code> 与控件名相连：</p> <figure class="highlight"><pre><code class="language-css" data-lang="css"><span></span><span class="c">/* 实际形式：&lt;namespace&gt;-&lt;component-name&gt;-(variable-name|property-name) */</span>
<span class="o">$</span><span class="nt">__petals--button-font-size</span><span class="o">:</span> <span class="nt">--petals-button-font-size</span><span class="o">;</span>
<span class="o">$</span><span class="nt">__petals--button-line-height</span><span class="o">:</span> <span class="nt">--petals-button-line-height</span><span class="o">;</span>

<span class="c">/* 实际形式：&lt;namespace&gt;-&lt;component-name&gt;-&lt;modifier-name&gt;-&lt;state&gt;-(variable-name|property-name) */</span>
<span class="o">$</span><span class="nt">petals--button-primary-focus-color</span><span class="o">:</span> <span class="nt">var</span><span class="o">($</span><span class="nt">__petals--primary-active-color</span><span class="o">,</span> <span class="o">$</span><span class="nt">petals--primary-active-color</span><span class="o">)</span> <span class="o">!</span><span class="nt">default</span><span class="o">;</span>
<span class="o">$</span><span class="nt">petals--button-primary-focus-bg</span><span class="o">:</span> <span class="nt">var</span><span class="o">($</span><span class="nt">__petals--primary-active-bg</span><span class="o">,</span> <span class="o">$</span><span class="nt">petals--primary-active-bg</span><span class="o">)</span> <span class="o">!</span><span class="nt">default</span><span class="o">;</span></code></pre></figure> <h3 id="section-2">控件属性与事件</h3> <p>事件命名的基本形式是「on-」后接动词，如：<code>onClick</code>、<code>onChange</code>。但有时只接一个动词无法确切表达，需在动词前加名词用作补充，如：<code>onSelectionChange</code>、<code>onVisibilityChange</code>。</p> <h2 id="section-3">设计原则</h2> <h3 id="section-4">顺其「自然」</h3> <p>「控件」是什么？可以认为它是一个返回视图结构的函数，而控件的属性（prop）和事件（event）就是这个「函数」的参数。属性是控件的外部与其内部进行主动通信的数据，事件则是进行被动通信的回调函数。</p> <p>一个封装得好的函数，它的参数应尽可能少，要想明白每个参数的语义，且必须确实有其存在的意义——控件的属性和事件的设计也该如此。</p> <p>在设计控件的属性时，先思考下要加的这个属性是不是属于这个控件本身的特性？若不是，那要加的属性的值所对应的控件的特性是什么？如果这两个问题都没有得到答案，那么这个属性可以不用加了。</p> <p>控件的属性只应与其本身的特性有关，与业务意义无关——自身特性是自然特性，业务意义是附加特性。</p> <p>比如，一个按钮控件通常会有「主要」、「次要」和「危险」这几种多少与业务沾边的语义，那么控件的属性该如何设计来满足这种需求呢？</p> <p>Ant Design 和 Element 的做法是将其作为 <code>type</code> 属性的值或独立成一个属性：</p> <figure class="highlight"><pre><code class="language-html" data-lang="html"><span></span><span class="p">&lt;</span><span class="nt">Button</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;primary&quot;</span><span class="p">&gt;</span>Ant Design 中的主要按钮<span class="p">&lt;/</span><span class="nt">Button</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">Button</span><span class="p">&gt;</span>Ant Design 中的次要（默认）按钮<span class="p">&lt;/</span><span class="nt">Button</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">Button</span> <span class="na">danger</span><span class="p">&gt;</span>Ant Design 中的危险按钮<span class="p">&lt;/</span><span class="nt">Button</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">el-button</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;primary&quot;</span><span class="p">&gt;</span>Element 中的主要按钮<span class="p">&lt;/</span><span class="nt">el-button</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">el-button</span><span class="p">&gt;</span>Element 中的次要（默认）按钮<span class="p">&lt;/</span><span class="nt">el-button</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">el-button</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;danger&quot;</span><span class="p">&gt;</span>Element 中的危险按钮<span class="p">&lt;/</span><span class="nt">el-button</span><span class="p">&gt;</span></code></pre></figure> <p>按照上面说的控件属性设计原则来看，「主要」、「次要」和「危险」作用到按钮控件上的表现主要是颜色发生了变化，所以应该去用表示按钮的自然特性「颜色」的 <code>color</code> 属性来满足同样的需求：</p> <figure class="highlight"><pre><code class="language-html" data-lang="html"><span></span><span class="p">&lt;</span><span class="nt">button</span> <span class="na">color</span><span class="o">=</span><span class="s">&quot;primary&quot;</span><span class="p">&gt;</span>主要按钮<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span>次要（默认）按钮<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">button</span> <span class="na">color</span><span class="o">=</span><span class="s">&quot;danger&quot;</span><span class="p">&gt;</span>危险按钮<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 还可以扩展出其他任意多颜色的按钮 --&gt;</span>
<span class="p">&lt;</span><span class="nt">button</span> <span class="na">color</span><span class="o">=</span><span class="s">&quot;f00&quot;</span><span class="p">&gt;</span>红色按钮<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">button</span> <span class="na">color</span><span class="o">=</span><span class="s">&quot;yellow&quot;</span><span class="p">&gt;</span>黄色按钮<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">button</span> <span class="na">color</span><span class="o">=</span><span class="s">&quot;blue&quot;</span><span class="p">&gt;</span>蓝色按钮<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span></code></pre></figure> <p>若控件的某组特性是二元对立的，如「禁用」与「启用」，则选择默认不生效的那个作为属性，且属性值是布尔型，默认值为 <code>false</code>。</p> <p>还是拿按钮控件来举例：如果默认是「禁用」，那就设计一个代表「启用」的 <code>enabled</code> 属性，其默认值是 <code>false</code>，只要控件在被使用时传入了 <code>enabled</code>，就变成了「启用」状态；反之亦然。</p> <p>另外，控件的属性值尽可能是简单数据类型，也就是数字、字符串等。</p> <p>如果控件需要处理具有业务、配置语义的东西，该怎么弄？先来拿人做类比，帮助理解下——</p> <p>人有头、躯干、四肢、脑、五脏六腑等组成部分，经过脑活动可以进行交流、创造等——这些是人的自然特性。人的职业、角色、身份等是自然特性吗？当然不是！这些是人脑的运作机制在特定的环境、上下文中对接收到的信息处理后所形成的结果。</p> <p>由此可见，人的自然特性是有限的，而由自然特性所衍生出来职业、角色、身份等则是无限的。鉴于此，倘若把控件的非自然特性设计为属性，其数量将多如牛毛。那些具有业务、配置语义的东西，理应作为环境、上下文被控件内部起到人脑作用的程序所「理解」，并做出相应的「反应」或「动作」。</p> <p>在 Petals 中，作为「人脑」存在的是控件配置的 setter 与 getter、每个控件的无头组件及结构组件的基类。</p> <h3 id="section-5">受控结构生成</h3> <p>什么是「受控结构」？在这里是指「可被使用者自定义的受控件本身控制的内部结构」。它有别于子控件，会被渲染到控件内部预先设置的「指定坑位」——Vue 中具名插槽的内容就是。</p> <p>具名插槽是个很是便利的机制，即便如此，作为一个跨环境的控件体系，要么在每个环境中都实现具名插槽机制，要么在 Vue 中舍弃具名插槽而另辟蹊径——显然后者是更明智的选择。</p> <p>不考虑具名插槽，生成受控结构主要有两个手段：一是通过控件的属性传入数据结构或返回数据结构的函数，如所谓的「render prop」，常用于比较简单的结构；二是设计专门的控件，如 Ant Design 中的 <code>TabPane</code> 之于 <code>Tabs</code>，主要在结构较为复杂时使用。</p> <p>在 Ant Design 中，控件属性大量使用虚拟 DOM 节点，这违背了「属性值尽可能是简单数据类型」的原则，在 Petals 里是反模式。</p> <p>假如有个 <code>Card</code>，它的内部从上到下被划分为 header、body 和 footer 三个部分：header 中是标题、图标和一些操作；子控件被放在 body 内；footer 中则可以是操作或其他附加信息。默认情况下，header 和 footer 中是没内容的，所以连它们本身都不生成。</p> <p>这要设计一个字符串类型的 <code>title</code> 属性用来设置标题，在使用者给这个属性传值后会生成 header。当使用者想在标题前显示图标，或在 <code>Card</code> 的右上角显示一些操作时，该怎么办？</p> <p>Ant Design 的做法是 <code>title</code> 属性接收虚拟 DOM 节点，这就可以传入一个视图结构了；同理，又弄了个接收虚拟 DOM 节点的 <code>extra</code> 属性去控制 <code>Card</code> 右上角的结构。</p> <p>在这里，符合原则的做法是——设计一个专门的控件，姑且叫做 <code>CardHeader</code>，作用就是让使用者能够完全自定义 header 中的内容；当检测到 <code>CardHeader</code> 时就忽略 <code>title</code> 属性。</p> <p>为什么不是给 <code>Card</code> 添加 <code>icon</code> 属性去控制图标的显示，设计 <code>actions</code> 属性传入对象数组去生成右上角的操作呢？</p> <p>首先，如果把 <code>icon</code> 和 <code>actions</code> 这两个属性加到 <code>Card</code> 上，没看过使用手册的使用者在看到它们时，第一反应会想到它们实际是影响 header 部分吗？</p> <p>若是加到 <code>Card</code> 上，它们既可以被理解成在 header 里，又可以被认为是在 body 或 footer 里，因为这两个词不具备唯一性，不像 <code>title</code>；反而加到 <code>CardHeader</code> 上比较合适。</p> <p>其次，要是非要直接通过 <code>Card</code> 来控制，就得加上限定词让人更容易理解，如：<code>headerIcon</code>、<code>headerActions</code>。但这样一来，结构控制都集中到了 <code>Card</code> 上，它的属性将越来越多，这就又违背了「控件属性和事件应尽可能少」的原则。</p> <p>再者，如上面所说，用复杂数据类型做属性值是要尽量避免的，即用数字、字符串等简单数据类型做属性值。虽然如此，但有时传对象或数组却可能会更合适些。</p> <p>比如，有些控件会包含一些可自定义的操作，这种情况下再让使用者手动拼个视图结构的话，未免太不贴心了；这时若能通过传入一组代表操作配置的数据结构去生成一堆按钮，应该会更好些。需要注意的是，这个配置应当是（一定范围内）规范化的对操作（动作）的抽象。</p> <p>总而言之，受控结构的生成优先考虑设计一个专门的控件，让属性列表尽可能简洁与整洁，把视图结构放回到它该待的地方；「不得已」时可以采用一个接收具有配置语义的数据结构的属性，如可能泛化的操作配置。</p> <h3 id="section-6">样式</h3> <p>在结构组件中对接视觉组件时，要用 <a href="https://github.com/css-modules/css-modules">CSS Modules</a>，以避免外部的样式代码所引起的非预期效果。</p> <h2 id="api-">API 索引</h2> <p>设计控件 API 时经过思考抉择所沉淀的「词汇表」，在进行后续的控件设计时优先使用这里罗列的 API。</p> <h3 id="section-7">控件属性</h3> <table> <thead> <tr> <th>语义</th> <th>属性名</th> <th>值类型/可选值</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>自定义类名</td> <td><code>className</code></td> <td>视情况而定</td> <td>全控件通用</td> </tr> <tr> <td>自定义样式</td> <td><code>style</code></td> <td><code>object</code></td> <td>全控件通用</td> </tr> <tr> <td>数据源</td> <td><code>dataSource</code></td> <td><code>object | object[]</code></td> <td>视图类控件使用</td> </tr> <tr> <td>当前值</td> <td><code>value</code></td> <td>视情况而定</td> <td>字段类控件使用</td> </tr> <tr> <td>默认值</td> <td><code>defaultValue</code></td> <td>视情况而定</td> <td>字段类控件使用</td> </tr> <tr> <td>可清除</td> <td><code>clearable</code></td> <td><code>boolean</code></td> <td>字段类控件使用</td> </tr> <tr> <td>可搜索</td> <td><code>searchable</code></td> <td><code>boolean</code></td> <td>字段类控件使用</td> </tr> <tr> <td>唯一标识</td> <td><code>flag</code></td> <td><code>string | number</code></td> <td>列表条目使用，默认生成时以数组索引为依据，而不是「第几个」</td> </tr> <tr> <td>当前激活项标识</td> <td><code>activeFlag</code></td> <td><code>string | number</code></td> <td>列表使用，默认生成时是数组索引下标 <code>0</code>，而不是「第一个」的 <code>1</code></td> </tr> <tr> <td>列表条目被选中</td> <td><code>selected</code></td> <td><code>boolean</code></td> <td>-</td> </tr> <tr> <td>单选框、多选框被选中</td> <td><code>checked</code></td> <td><code>boolean</code></td> <td>若单选框、多选框是在列表条目中，使用 <code>selected</code> 而非 <code>checked</code></td> </tr> <tr> <td>条目铺展方向</td> <td><code>direction</code></td> <td><code>'horizontal' | 'vertical'</code></td> <td>「列表」类控件对子控件的铺展方向进行控制</td> </tr> <tr> <td>尺寸</td> <td><code>size</code></td> <td><code>'large' | 'medium' | 'small'</code></td> <td>-</td> </tr> <tr> <td>形状</td> <td><code>shape</code></td> <td>视情况而定</td> <td>-</td> </tr> <tr> <td>位置</td> <td><code>placement</code></td> <td>视情况而定</td> <td>有的控件可以指定出现（放置）的「位置」，这种场景用 <code>placement</code> 而不用 <code>position</code></td> </tr> <tr> <td>弹出层触发方式</td> <td><code>trigger</code></td> <td>视情况而定</td> <td>-</td> </tr> <tr> <td>弹出层类名</td> <td><code>popupClassName</code></td> <td>视情况而定</td> <td>-</td> </tr> <tr> <td>标题</td> <td><code>title</code></td> <td><code>string</code></td> <td> </td> </tr> <tr> <td>内容</td> <td><code>content</code></td> <td><code>string</code></td> <td>主要性质的文本，一般较为详细</td> </tr> <tr> <td>文本标签</td> <td><code>label</code></td> <td><code>string</code></td> <td> </td> </tr> <tr> <td>描述</td> <td><code>description</code></td> <td><code>string</code></td> <td>辅助性质的文本，一般较为简洁</td> </tr> <tr> <td>对齐方式</td> <td><code>alignment</code></td> <td>视情况而定</td> <td>文本或布局的对齐方式</td> </tr> <tr> <td>密度</td> <td><code>density</code></td> <td><code>'high' | 'medium' | 'low'</code></td> <td>内容的密集程度，主要用于「列表」类视图</td> </tr> </tbody> </table> <h3 id="section-8">控件事件</h3> <table> <thead> <tr> <th>语义</th> <th>事件名</th> <th>回调函数</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>弹出层可见性变化</td> <td><code>onVisibleChange</code></td> <td><code>(visible: boolean) =&gt; void</code></td> <td>-</td> </tr> <tr> <td>选取列表中的条目</td> <td><code>onSelect</code></td> <td><code>((flag: string | number) =&gt; void) | ((flags: (string | number)[]) =&gt; void)</code></td> <td>-</td> </tr> <tr> <td>树形结构节点展开状态变化</td> <td> </td> <td> </td> <td> </td> </tr> </tbody> </table> <h3 id="a--b">为何是 A 非 B</h3> <p>记录在做 API 设计时的抉择。</p> <h4 id="a--operationtextb--operations">A = <code>operationText</code>，B = <code>operations</code></h4> <p>在自定义 <code>Transfer</code> 的操作文案时，Ant Design 和 iView 的相关 API 命名为 <code>operations</code>，Element 为 <code>button-texts</code>。</p> <p>由于「操作」在视觉上未必是「按钮」的形态，选择语义更为泛化一些的 <code>operation</code> 比 <code>button</code> 合适。</p> <p>并且，可自定义的只有文案，单纯的 <code>operation</code> 在语义上所包含的内容更多一些，因此要加上 <code>text</code> 去限制住理解上的「可自定义的范围」。</p> <p>另外，在计算机相关场景中，<code>text</code> 是不可数名词。</p> </div> <footer class="Article-footer col-md-3"> <div class="Widget Widget--share"> <div class="Widget-body"> <p>分享到<i class="fa fa-share-alt"></i></p> <div class="social-share" data-sites="wechat,weibo,twitter"></div> </div> </div> <section class="Widget Widget--toc"> <div class="Widget-header"> <h2 class="Widget-title">目录</h2> </div> <div class="Widget-body"></div> </section> </footer> </article> <footer class="Page-footer Footer"> <div class="container-fluid"> <div class="Footer-description"> <!-- 重要链接 --> <nav class="Footer-navs"> <ul> <li><a href="https://ntks.ourai.ws/" title="让前端开发更加有序，让业务开发专注业务" target="_blank" rel="external nofollow"><span>反混沌</span></a></li> <li><a href="https://handiejs.github.io/" title="渐进式配置驱动企业级中后台前端应用开发框架" target="_blank" rel="external nofollow"><span>Handie</span></a></li> <li><a href="https://github.com/petals-ui" target="_blank" rel="external nofollow"><span>GitHub</span></a></li> </ul> </nav> <!-- 网站版权 --> <div class="Footer-copyright"> <p>&copy; 2019-2023 <a href="https://ntks.ourai.ws/" title="访问「反混沌」" target="_blank" rel="external nofollow">反混沌</a> 版权所有</p> <p>由 <a href="https://ourai.ws/" title="访问「欧雷流」" target="_blank" rel="external nofollow">欧雷</a> 用 ♥ 设计与开发</p> </div> </div> </div> </footer> </main> </div> <script>$('table').addClass('table table-bordered')</script> <script type="text/javascript" src="/assets/share.min-3155ee636b84a04d036e0f1ba833227d3fd03a4c58a6f2e21c9ceb1c5d0198c7.js"></script><script type="text/javascript" src="/assets/components-a266f21fe1dfd61bebf40e74872cbf901eb3e201f7d33e9e5d5af9a55f4b24ea.js"></script> <script type="text/javascript" src="/assets/initializers/time-8d7a529a66ae6cb53c2283d21fd6a12c538b8473dd5bd76458366d09adce7bf6.js"></script><script type="text/javascript" src="/assets/initializers/lazyload-44b7df8a9282d598284d522e64d6be9ac88d466f3c4a734a514303e99347b2c9.js"></script> </body> </html>
